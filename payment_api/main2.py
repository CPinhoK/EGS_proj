from fastapi import FastAPI , HTTPException, Request
from pydantic import BaseModel

import databases
import sqlalchemy

import random
import string

### Database configuration
DATABASE_URL = "sqlite:///./test.db"

database = databases.Database(DATABASE_URL)

metadata = sqlalchemy.MetaData()

payment_details_t = sqlalchemy.Table(  ##payment_details table
    "payment_details_t",
    metadata,
    sqlalchemy.Column("paymentid", sqlalchemy.String, primary_key=True),
    sqlalchemy.Column("totaltopay", sqlalchemy.FLOAT),
    sqlalchemy.Column("metodo_de_pagamento", sqlalchemy.String),
    sqlalchemy.Column("source", sqlalchemy.String),
    sqlalchemy.Column("payment_dec", sqlalchemy.String),
)

wallet_t = sqlalchemy.Table(  ##wallet table
    "wallet_t",
    metadata,
    sqlalchemy.Column("wallet_id", sqlalchemy.String, primary_key=True,unique=True),
    sqlalchemy.Column("cash_assoc", sqlalchemy.FLOAT),
    sqlalchemy.Column("niff", sqlalchemy.Integer,unique=True),
    sqlalchemy.Column("wallet_desc", sqlalchemy.String),
    sqlalchemy.Column("user_id", sqlalchemy.String),
)

engine = sqlalchemy.create_engine(
    DATABASE_URL, connect_args={"check_same_thread": False}
)
metadata.create_all(engine)



##MODELS

class Payment_details(BaseModel):
    paymentid : str 
    totaltopay: float
    metodo_de_pagamento: str
    source: str | None = None
    payment_dec : str | None = None

class Wallet(BaseModel):
    wallet_id: str
    cash_assoc: float 
    niff: int | None = None
    wallet_desc: str | None = None
    user_id: str
 
class Wallet_in(BaseModel):
    niff: int | None = None
    wallet_desc: str | None = None
    #user_id: str        #user id comes from the header
    #wallet_id: str      #randomly generated by me
    #cash_assoc: float   #Wallet starts with gifted 2$
    
class Wallet_update(BaseModel):
    niff: int | None = None
    wallet_desc: str | None = None
    cash_assoc: float   #cash to be added to the wallet in a update





app = FastAPI()


@app.get("/")
async def root():
    return {"message": "Hello Payz"}

@app.get("/status")
async def get_status():
    return 0

@app.post("/payment")
async def payment_request(payment_details: Payment_details,request: Request):
    
    uid = await are_credentials_correct(request) #after this the payment should proceed
    
    ## proceed with the payment
    
    return {"message": "Payment sucessfull"}
    
@app.get("/authenticate")
async def authenticate(uid:str,token:str):
    #ask auth if credentials add up
    
    if(uid=="notvalid" or token=="notvalid"):
        return 1 
    return 0

@app.get("/wallet")
async def get_all_wallets(request: Request):
    
    uid = await are_credentials_correct(request) #after this wallets info can be displayed
    
    query_sel = sqlalchemy.select(wallet_t.c).where(wallet_t.c.user_id == uid)
    #print(query_sel)
    wallets_info = await database.fetch_all(query_sel)
    if wallets_info==[]:
        raise HTTPException(status_code=400, detail="User does not have wallets")
    
    return {"Wallets info": wallets_info}

@app.get("/wallet/{wallet_id}")
async def get_wallet(wallet_id: str,request: Request):

    uid = await are_credentials_correct(request) #after this wallet info can be displayed
    
    query_sel = sqlalchemy.select(wallet_t.c).where(wallet_t.c.user_id == uid, wallet_t.c.wallet_id==wallet_id)
    #print(query_sel)
    wallet_info = await database.fetch_all(query_sel)
    if wallet_info==[]:
        raise HTTPException(status_code=400, detail="Invalid wallet id")

    return {"Wallet info": wallet_info}

@app.post("/wallet")
async def create_wallet(wallet: Wallet_in,request: Request):
    
    uid=await are_credentials_correct(request) #wallet can now be created

    ##search database for a wallet with the same niff
    query_sel = sqlalchemy.select(wallet_t.c.niff)
    #print(query_sel)
    niffs = await database.fetch_all(query_sel)
    niffs = [niff[0] for niff in niffs]
    if wallet.niff in niffs:
        #print("A wallet with that niff already exists")
        raise HTTPException(status_code=406, detail="A wallet with that niff already exists")
    
    ##generate a wallet id/test if that id already exists
    query_sel = sqlalchemy.select(wallet_t.c.wallet_id)
    wallet_ids = await database.fetch_all(query_sel)
    wallet_ids = [wallet_id[0] for wallet_id in wallet_ids]
    new_walletid=id_generator()
    while(new_walletid in wallet_ids):
        new_walletid=id_generator()
    
    ##create the wallet
    query_in = wallet_t.insert().values(wallet_id=new_walletid, cash_assoc=2 ,niff=wallet.niff ,wallet_desc=wallet. wallet_desc,user_id=uid)
    last_record_id = await database.execute(query_in)
    return {**wallet.dict(), "id": last_record_id}


@app.put("/wallet/{wallet_id}")
async def update_wallet(wallet_id: str,wallet: Wallet_update,request: Request):
    
    uid=await are_credentials_correct(request) #wallet can now be updated
    
    ##make sure this wallet belongs to the user
    query_sel = sqlalchemy.select(wallet_t.c).where(wallet_t.c.user_id == uid, wallet_t.c.wallet_id==wallet_id)
    #print(query_sel)
    wallet_info = await database.fetch_all(query_sel)
    #print(wallet_info)
    if wallet_info==[]:
        raise HTTPException(status_code=406, detail="Invalid wallet ID")
    
    ##get current wallet cash
    query_sel = sqlalchemy.select(wallet_t.c.cash_assoc).where(wallet_t.c.user_id == uid, wallet_t.c.wallet_id==wallet_id)
    #print(query_sel)
    wallet_cash = await database.fetch_all(query_sel)
    cuurent_wallet_cash = wallet_cash[0][0]
    print(cuurent_wallet_cash)
    newcash=cuurent_wallet_cash+abs(wallet.cash_assoc)
    
    ##Make sure you want to change the niff
    if wallet.niff != None:
        
        ##search database for a wallets with the same niff
        query_sel = sqlalchemy.select(wallet_t.c.niff)
        #print(query_sel)
        niffs = await database.fetch_all(query_sel)
        niffs = [niff[0] for niff in niffs]
        if wallet.niff in niffs:
            #print("A wallet with that niff already exists")
            raise HTTPException(status_code=406, detail="A wallet with that niff already exists")
        
        query_update = wallet_t.update().values(niff=wallet.niff,wallet_desc=wallet.wallet_desc,cash_assoc=newcash).where(wallet_t.c.wallet_id==wallet_id)
    else:
        query_update = wallet_t.update().values(wallet_desc=wallet.wallet_desc,cash_assoc=newcash).where(wallet_t.c.wallet_id==wallet_id)
    
    ##Update wallet
    last_record_id = await database.execute(query_update)
    
    return {"detail":"Wallet with id "+wallet_id+" updated"}
    
@app.delete("/wallet/{wallet_id}")
async def delete_wallet(wallet_id: str,request: Request):
    
    uid=await are_credentials_correct(request) #wallet can now be destroyed
    
    ##make sure this wallet belongs to the user
    query_sel = sqlalchemy.select(wallet_t.c).where(wallet_t.c.user_id == uid, wallet_t.c.wallet_id==wallet_id)
    #print(query_sel)
    wallet_info = await database.fetch_all(query_sel)
    #print(wallet_info)
    if wallet_info==[]:
        raise HTTPException(status_code=406, detail="Invalid wallet ID")
    
    ##Delete wallet
    query_del = wallet_t.delete().where(wallet_t.c.wallet_id==wallet_id)
    last_record_id = await database.execute(query_del)

    return {"detail":"Wallet with id "+wallet_id+" deleted"}


##oldauth for tests

@app.get("/oldauth")
async def oldauth(request: Request):
    #print(request.headers.items())
    uid,token=None,None
    if(good_auth_header(request)):
        uid,token=split_header(request)
        #print("UID:"+uid+"\nToken:"+token)
    else:
        raise HTTPException(status_code=404, detail="Invalid Credentials")
    return {"Accept header": (uid,token) }








async def are_credentials_correct(request: Request):
    if(good_auth_header(request)):
        uid,token=split_header(request)
        #print("UID:"+uid+"\nToken:"+token)
    else:
        raise HTTPException(status_code=404, detail="Invalid Credentials")
    
    value=await authenticate(uid,token)
    #print({"Accept header": (uid,token) ,"Value":value})
    if value!=0:
        raise HTTPException(status_code=401, detail="Unauthorized acesss")
    return uid


def good_auth_header(request: Request):
    header = request.headers.get('auth')
    #print(header)
    if header is None:
        return False
    header=' '.join(header.split()) #convert multiple spaces in 1
    header=header.split(" ")
    if(len(header) != 2):
        return False
    return True 

def split_header(request: Request):
    header = request.headers.get('auth')
    header=' '.join(header.split())  #convert multiple spaces in 1
    header=header.split(" ")
    uid = header[0]
    token= header[1]
    return(uid,token)

def id_generator(size=17, chars=string.ascii_uppercase + string.digits + string.ascii_lowercase):
    return ''.join(random.choice(chars) for a in range(size))